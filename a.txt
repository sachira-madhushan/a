Write suitable Java code to merge two sorted linked lists (11, 12) and return it as a new sorted list. 
The new list should be made by splicing together the nodes of the first two lists. 
Save the answer in the name of "Q1.java". 
The following constraints can be presumed: 
1. The number of nodes in both lists is in the range [0, 30]. 
2. -20 < = Node value â‰¤ 20 
3. Both 11 and 12 are sorted in non-decreasing order. 
Example: Input: Ia= [1,2,4], Ib = [1,3,4] Output : [1,1,2,3,4,4]

// Q1.java

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Q1 {
    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        if (l1 != null) {
            current.next = l1;
        } else {
            current.next = l2;
        }

        return dummy.next;
    }

    public static void main(String[] args) {
        ListNode l1 = new ListNode(1);
        l1.next = new ListNode(2);
        l1.next.next = new ListNode(4);

        ListNode l2 = new ListNode(1);
        l2.next = new ListNode(3);
        l2.next.next = new ListNode(4);

        ListNode mergedList = mergeTwoLists(l1, l2);

        // Print the merged list
        while (mergedList != null) {
            System.out.print(mergedList.val + " ");
            mergedList = mergedList.next;
        }
    }
}

--------------------------------------------------------------------------------------------------

//doubly linked list

Write a Java code to implement the following operations in "Doubly Linked List" and save it as "Q2.java".

i. Delete a node at the front of a list

ii. Delete a node at the end of a list

iii. Delete a node before a given node of a list

iv. Delete a node after a given node of a list


/// Q2.java

class Node {
    int data;
    Node prev;
    Node next;

    Node(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

class DoublyLinkedList {
    private Node head;
    private Node tail;

    DoublyLinkedList() {
        this.head = null;
        this.tail = null;
    }

    // Insert a node at the front of the list
    public void insertAtFront(int data) {
        Node newNode = new Node(data);

        if (head == null) {
            head = newNode;
            tail = newNode;
        } else {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        }
    }

    // Insert a node at the end of the list
    public void insertAtEnd(int data) {
        Node newNode = new Node(data);

        if (tail == null) {
            head = newNode;
            tail = newNode;
        } else {
            newNode.prev = tail;
            tail.next = newNode;
            tail = newNode;
        }
    }

    // Delete a node at the front of the list
    public void deleteAtFront() {
        if (head == null) {
            System.out.println("List is empty. Nothing to delete.");
            return;
        }

        if (head == tail) {
            head = null;
            tail = null;
        } else {
            head = head.next;
            head.prev = null;
        }
    }

    // Delete a node at the end of the list
    public void deleteAtEnd() {
        if (tail == null) {
            System.out.println("List is empty. Nothing to delete.");
            return;
        }

        if (head == tail) {
            head = null;
            tail = null;
        } else {
            tail = tail.prev;
            tail.next = null;
        }
    }

    // Delete a node before a given node of the list
    public void deleteBefore(Node node) {
        if (node == null || node.prev == null) {
            System.out.println("Cannot delete. Invalid node or node has no previous node.");
            return;
        }

        Node prevNode = node.prev;

        if (prevNode == head) {
            deleteAtFront();
        } else {
            prevNode.prev.next = node;
            node.prev = prevNode.prev;
        }
    }

    // Delete a node after a given node of the list
    public void deleteAfter(Node node) {
        if (node == null || node.next == null) {
            System.out.println("Cannot delete. Invalid node or node has no next node.");
            return;
        }

        Node nextNode = node.next;

        if (nextNode == tail) {
            deleteAtEnd();
        } else {
            node.next = nextNode.next;
            nextNode.next.prev = node;
        }
    }

    // Display the contents of the list
    public void display() {
        Node current = head;

        if (current == null) {
            System.out.println("List is empty.");
            return;
        }

        System.out.print("List: ");

        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }

        System.out.println();
    }
}

public class Q2 {
    public static void main(String[] args) {
        DoublyLinkedList dll = new DoublyLinkedList();

        dll.insertAtEnd(10);
        dll.insertAtEnd(20);
        dll.insertAtEnd(30);
        dll.insertAtFront(5);
        dll.insertAtFront(2);
        dll.insertAtEnd(40);
        dll.insertAtEnd(50);

        dll.display(); // List: 2 5 10 20 30 40 50

        dll.deleteAtFront();
        dll.display(); // List: 5 10 20 30 40 50

        dll.deleteAtEnd();
        dll.display(); // List: 5 10 20 30 40

        Node node = dll.head.next.next; // Node with value 20
        dll.deleteBefore(node);
        dll.display(); // List: 5 20 30 40

        node = dll.tail.prev.prev; // Node with value 30
        dll.deleteAfter(node);
        dll.display(); // List: 5 20 30

        node = dll.head.next; // Node with value 20
        dll.deleteAfter(node);
        dll.display(); // List: 5 20

        dll.deleteAtFront();
        dll.display(); // List: 20

        dll.deleteAtEnd();
        dll.display(); // List is empty.
    }
}

------------------------------------------------------------------------------------------------------
Implement the followings using Java.

a). Create a class called Link to hold the following data items and save it as "Q3a".
Name: Link
Student Name: sname as string type
Student Id: sid string type
Course Name: cid string type
Course Fee: cfee double
Reference to node: next

b). Create a constructor for the above class to initialize the items and save it as "Q3b"

// Q3a.java

class Link {
    String sname;
    String sid;
    String cid;
    double cfee;
    Link next;
}

// Q3b.java

class Link {
    String sname;
    String sid;
    String cid;
    double cfee;
    Link next;

    Link(String sname, String sid, String cid, double cfee) {
        this.sname = sname;
        this.sid = sid;
        this.cid = cid;
        this.cfee = cfee;
        this.next = null;
    }
}
-------------------------------------------------------------------------------------------------------------

Use the class in "Q3" to do the following linked list operations.
a). Write a method to insert at least five records at the front of the linked list save it as "Q4a".
b). Write a method to search a record for a given Student Id save it as "Q4b".
c). Write a method to delete a record by the search using Student Id

// Q4a.java

class LinkedList {
    Link head;

    public void insertAtFront(String sname, String sid, String cid, double cfee) {
        Link newLink = new Link(sname, sid, cid, cfee);

        if (head == null) {
            head = newLink;
        } else {
            newLink.next = head;
            head = newLink;
        }
    }
}

public class Q4a {
    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        // Insert at least five records at the front of the linked list
        linkedList.insertAtFront("John Doe", "001", "Mathematics", 500.0);
        linkedList.insertAtFront("Jane Smith", "002", "Physics", 600.0);
        linkedList.insertAtFront("Alice Johnson", "003", "Chemistry", 700.0);
        linkedList.insertAtFront("Bob Williams", "004", "Biology", 800.0);
        linkedList.insertAtFront("Eva Davis", "005", "English", 900.0);
    }
}

// Q4b.java

class LinkedList {
    Link head;

    // ... insertAtFront method

    public Link searchRecord(String sid) {
        Link current = head;

        while (current != null) {
            if (current.sid.equals(sid)) {
                return current;
            }
            current = current.next;
        }

        return null; // Record not found
    }
}

public class Q4b {
    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        // ... insertAtFront method

        // Search for a record with Student ID "003"
        Link foundRecord = linkedList.searchRecord("003");

        if (foundRecord != null) {
            System.out.println("Record found: " + foundRecord.sname);
        } else {
            System.out.println("Record not found.");
        }
    }
}

// Q4c.java

class LinkedList {
    Link head;

    // ... insertAtFront method
    // ... searchRecord method

    public void deleteRecord(String sid) {
        Link current = head;
        Link prev = null;

        // If the record to be deleted is the head node
        if (current != null && current.sid.equals(sid)) {
            head = current.next;
            return;
        }

        // Search for the record to be deleted
        while (current != null && !current.sid.equals(sid)) {
            prev = current;
            current = current.next;
        }

        // If the record is found, delete it
        if (current != null) {
            prev.next = current.next;
        }
    }
}

public class Q4c {
    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        // ... insertAtFront method
        // ... searchRecord method

        // Delete the record with Student ID "003"
        linkedList.deleteRecord("003");
    }
}
----------------------------------------------------------------------------------------------

Use the created array in Q1for the following task. Using java
a). Sort the array using Insertion Sort method and save it as "Q2a".

//insertion sort
public class InsertionSort {
    public static void main(String[] args) {
        int[] array = {4, 2, 9, 1, 5}; // Assuming you have an array as mentioned in Q1
        System.out.println("Original array: ");
        printArray(array);

        // Sort the array using Insertion Sort
        insertionSort(array);

        System.out.println("Sorted array (Q2a): ");
        printArray(array);
    }

    public static void insertionSort(int[] array) {
        int n = array.length;
        for (int i = 1; i < n; ++i) {
            int key = array[i];
            int j = i - 1;

            // Move elements of array[0..i-1], that are greater than key,
            // to one position ahead of their current position
            while (j >= 0 && array[j] > key) {
                array[j + 1] = array[j];
                j = j - 1;
            }
            array[j + 1] = key;
        }
    }

    public static void printArray(int[] array) {
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}

------------------------------------------------------------------------------------------------------

//binary search
b). Search an element in the array using Binary Recursive Search with the following features and save it as "Q2b".
1. Integers to be entered during run time.
2. Prompt the search value.
3. Create separate functions for Insertion Sort and Binary search.

import java.util.Arrays;
import java.util.Scanner;

public class BinarySearch {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of elements in the array: ");
        int size = scanner.nextInt();

        int[] array = new int[size];

        System.out.println("Enter the elements of the array:");
        for (int i = 0; i < size; i++) {
            array[i] = scanner.nextInt();
        }

        // Sort the array using Insertion Sort
        insertionSort(array);

        System.out.print("Sorted array (Q2a): ");
        printArray(array);

        System.out.print("Enter the search value: ");
        int searchValue = scanner.nextInt();

        int index = binarySearch(array, searchValue, 0, array.length - 1);

        if (index != -1) {
            System.out.println("Element found at index " + index + " (Q2b).");
        } else {
            System.out.println("Element not found in the array.");
        }
    }

    public static void insertionSort(int[] array) {
        int n = array.length;
        for (int i = 1; i < n; ++i) {
            int key = array[i];
            int j = i - 1;

            while (j >= 0 && array[j] > key) {
                array[j + 1] = array[j];
                j = j - 1;
            }
            array[j + 1] = key;
        }
    }

    public static int binarySearch(int[] array, int searchValue, int low, int high) {
        if (low <= high) {
            int mid = low + (high - low) / 2;

            if (array[mid] == searchValue) {
                return mid;
            }

            if (array[mid] > searchValue) {
                return binarySearch(array, searchValue, low, mid - 1);
            }

            return binarySearch(array, searchValue, mid + 1, high);
        }

        return -1;
    }

    public static void printArray(int[] array) {
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}

------------------------------------------------------------------------------------------------------------
//BubbleSort

public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Swap arr[j] and arr[j+1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("Original array:");
        for (int element : arr) {
            System.out.print(element + " ");
        }

        bubbleSort(arr);

        System.out.println("\nSorted array:");
        for (int element : arr) {
            System.out.print(element + " ");
        }
    }
}

----------------------------------------------------------------------------------------------------------------
//SelectionSort

public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;

        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            // Swap arr[i] with the minimum element
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("Original array:");
        for (int element : arr) {
            System.out.print(element + " ");
        }

        selectionSort(arr);

        System.out.println("\nSorted array:");
        for (int element : arr) {
            System.out.print(element + " ");
        }
    }
}
-------------------------------------------------------------------------------------------------

//MergeSort

public class MergeSort {
    public static void mergeSort(int[] arr) {
        if (arr.length < 2) {
            return;
        }

        int mid = arr.length / 2;
        int[] left = new int[mid];
        int[] right = new int[arr.length - mid];

        System.arraycopy(arr, 0, left, 0, mid);
        System.arraycopy(arr, mid, right, 0, arr.length - mid);

        mergeSort(left);
        mergeSort(right);
        merge(arr, left, right);
    }

    private static void merge(int[] arr, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;

        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                arr[k] = left[i];
                i++;
            } else {
                arr[k] = right[j];
                j++;
            }
            k++;
        }

        while (i < left.length) {
            arr[k] = left[i];
            i++;
            k++;
        }

        while (j < right.length) {
            arr[k] = right[j];
            j++;
            k++;
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("Original array:");
        for (int element : arr) {
            System.out.print(element + " ");
        }

        mergeSort(arr);

        System.out.println("\nSorted array:");
        for (int element : arr) {
            System.out.print(element + " ");
        }
    }
}

--------------------------------------------------------------------------------------------------------------------

//QuickSort

public class QuickSort {
    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }

    private static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int partitionIndex = partition(arr, low, high);

            quickSort(arr, low, partitionIndex - 1);
            quickSort(arr, partitionIndex + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }

        swap(arr, i + 1, high);
        return i + 1;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("Original array:");
        for (int element : arr) {
            System.out.print(element + " ");
        }

        quickSort(arr);

        System.out.println("\nSorted array:");
        for (int element : arr) {
            System.out.print(element + " ");
        }
    }
}

---------------------------------------------------------------------------------

//single link list
1. main file

public class Main
{

	public static void main(String[] args)
	{
		
		SingleLinkedList2 list = new SingleLinkedList2();
		
		list.insertLast(4);
		list.insertLast(2);
		list.insertAtStart(5);
		list.insertAt(1, 24);
		list.insertLast(65);
		list.insertLast(3);
		list.insertAtStart(7);
		list.insertAtStart(8);
		list.insertLast(6);
		list.insertAt(4, 9);
		list.insertAtStart(10);
		list.insertAtStart(11);
		list.insertAt(3, 21);
								// 10 8 21 5 24 9 4 2 65 3
								// 13
		
		list.show();
		list.countNodes();
		
		list.deleteLast();
		list.deleteAt(4);
		list.deleteFirst();
		list.show();
		list.countNodes();
		
		/* list.deleteAt(4);
		list.deleteLast();
		list.deleteFirst();
		
		list.show();
		list.countNodes(); */
	}

}

2. node file
public class Node
{
	int data;
	Node next; // default value of next = null
	
	Node(int data) //6
	{
		this.data = data; // 6
	}
}

// new node => 6, null

3. 

class SingleLinkedList1
{
	public static void main(String args[])
	{	
		// Creating new nodes that are not connected together
		Node nodeA = new Node(6); // 6, null
		Node nodeB = new Node(3); // 3, null
		Node nodeC = new Node(4); // 4, null
		Node nodeD = new Node(2); // 2, null
		Node nodeE = new Node(1); // 1, null
		
		// Connecting the nodes
		Node head = nodeA;
		head.next = nodeB;
		nodeB.next = nodeC;
		nodeC.next = nodeD;
		nodeD.next = nodeE;
		
		// Printing the nodes
		System.out.println("head node is " + head.data); // 6
		System.out.println("second node is " + nodeB.data); // 3
		System.out.println("third node is " + nodeC.data); // 4
		System.out.println("fourth node is " + nodeD.data); // 2
		System.out.println("fifth node is " + nodeE.data); // 1
		
		System.out.println("Number of nodes: " + countNodes(head));
		
	}
	
	static int countNodes(Node head)
	{
		int count = 0;
		Node currentNode = head;
		while(currentNode != null)
		{
			count++;
			currentNode = currentNode.next;
		}
		return count;
	}
}

4.

public class SingleLinkedList2
{
	Node head;
	
	public void insertLast(int data)
	{
		Node newNode = new Node(data);
		
		if(head == null)
		{
			head = newNode;
		}
		
		else
		{
			Node current = head;
			while(current.next != null) 
			{
				current = current.next;
			}
			current.next =  newNode;
		}
		
	}
	
	public void insertAtStart(int data) // 5
	{
		Node newNode = new Node(data); // 5, null
		if(head == null)
		{
			head = newNode;
		}
		else
		{
			newNode.next = head;
			head = newNode;
		}
		
	}
	
	public void insertAt(int index, int data)
	{
		Node newNode = new Node(data); // 65, null
		
		if(index == 0)
		{
			insertAtStart(data);
		}
		
		else
		{
			Node current = head; // 20
			for(int i = 0; i < index-1; i++) // 0; 0<1
			{
				current = current.next; // 5
			}
			newNode.next = current.next; // 65, 20, 78
			current.next = newNode; // 5, 65, 20, 78
		}
	}
	
	public void deleteAt(int index)
	{
		if(index == 0)
		{
			head = head.next;
		}
		else
		{
			Node current = head;
			Node temp = null;
			for(int i = 0; i < index-1; i++)
			{
				current = current.next;
			}
			temp = current.next;
			current.next = temp.next;
			System.out.println("Deleted element is " + temp.data);
		}
	}
	
	public void deleteLast()
	{
		Node current = head;
		while(current.next.next != null)
		{
			current = current.next;
		}
		current.next = null;
	}
	
	public void deleteFirst()
	{
		Node current = head;
		head = current.next;
		// head = head.next;
	}
	
	public void countNodes()
	{
		int count = 0;
		Node current = head;
		while(current != null)
		{
			count++;
			current = current.next;
		}
		System.out.println("Number of nodes in the list: " + count);
		System.out.println();
	}
	
	public void show()
	{
		Node current = head;
		
		while(current != null)
		{
			System.out.println(current.data);
			current = current.next;
		}
		System.out.println();
	}
}

-----------------------------------------------------------------------------------------------

//Palindrome using Stack

import java.util.Stack;
import java.util.Scanner;
public class PalindromeStack {

        public static void main(String[] args) {

            System.out.print("Please enter any string: ");
            Scanner Sc =new Scanner(System.in);
            String inputString = Sc.nextLine();
            Stack stack = new Stack();

            for (int i = 0; i < inputString.length(); i++) {
                stack.push(inputString.charAt(i));
            }

            String reverseString = "";

            while (!stack.isEmpty()) {
                reverseString = reverseString+stack.pop();
            }

            if (inputString.equals(reverseString))
                System.out.println("Sting is a palindrome.");
            else
                System.out.println("Sting is not palindrome.");

        }
    }
---------------------------------------------------------------------------------------------------
// Palindrome using Queue
import java.util.Queue;
import java.util.Scanner;
import java.util.LinkedList;
class PalindromeQueue {

    public static void main(String[] args) {

    	System.out.print("Please enter any string: ");
        Scanner Sc =new Scanner(System.in);
        String inputString = Sc.nextLine();
        Queue queue = new LinkedList();

        for (int i = inputString.length()-1; i >=0; i--) {
            queue.add(inputString.charAt(i));
        }

        String reverseString = "";

        while (!queue.isEmpty()) {
            reverseString = reverseString+queue.remove();
        }
        if (inputString.equals(reverseString))
            System.out.println("Sting is a palindrome.");
        else
            System.out.println("Sting is not palindrome.");

    }
}

-------------------------------------------------------------------------------------------
//Palindrome using Stack and Queue

import java.util.Queue;
import java.util.Stack;
import java.util.Scanner;
import java.util.LinkedList;

public class PalindromeStacknQueue 
{
   public static void main(String[ ] args)
   {
	Scanner Sc = new Scanner(System.in); 
	String inputString;      
      	System.out.print("Please enter any string: ");
        inputString = Sc.next( );

	if (isPalindrome( inputString )){
		System.out.println("Sting is a palindrome.");
	}
	else{
		System.out.println("Sting is not palindrome.");
      	}
   }

   public static boolean isPalindrome(String input) 
   {   
      Queue<Character> x = new LinkedList<Character>( );
      Stack<Character> y = new Stack<Character>( );
      char letter;
      int i;
      
      for (i = 0; i < input.length( ); i++)
      {
	 letter = input.charAt(i);
         x.add(letter);
         y.push(letter);
      }    
      while (!x.isEmpty( ))
      {
         if (x.remove( ) != y.pop( ))
           return false;
      }
      return true; 
   }
    
}
